#!/usr/bin/env python3
#
# Copyright (C) 2016 Canonical, Ltd.
# Author: Scott Sweeny <scott.sweeny@canonical.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from snaplint._rule import Rule

import glob
import magic
import os
import platform
import subprocess

def _get_triplet():
    '''Return the appropriate arch triplet or empty string if it's not
    known
    '''

    return {
        'armv7l': 'arm-linux-gnueabihf',
        'aarch64': 'aarch64-linux-gnu',
        'x86_64': 'x86_64-linux-gnu',
    }.get(platform.machine(), '')

class LibraryRule(Rule):
    '''Examine the executables in the snap and make sure that only needed
    libraries are included'''

    def _get_executables(self):
        '''Get executables from the wrapper scripts generated by snapcraft
        '''
        executables = []

        # libmagic setup
        ms = magic.open(magic.NONE)

        if 'SNAP' in os.environ:
            # Load the libmagic db from $SNAP
            ms.load(os.path.join(os.environ['SNAP'], 'usr', 'share',
                                    'file', 'magic.mgc').encode())
        else:
            ms.load()

        for entry in glob.glob(self.path + 'command-*.wrapper'):
            with open(entry) as f:
                exec_line = f.readlines()[-1]
                exe = exec_line.split('"')[1].replace('$SNAP/', self.path)
                tp = ms.file(exe)
                if tp.startswith('ELF') and 'dynamically linked' in tp:
                    executables.append(exe)

        # libmagic teardown
        ms.close()
        return executables

    def _get_env(self):
        '''
        LD_LIBRARY_PATH=$SNAP/lib:$SNAP/usr/lib:$SNAP/lib/<triplet>:$SNAP/usr/lib/<triplet>
        '''
        env = os.environ.copy()
        env['LD_LIBRARY_PATH'] = (os.path.join(self.path, 'lib') + ':' +
                                  os.path.join(self.path, 'usr', 'lib') + ':' +
                                  os.path.join(self.path, 'lib',
                                               _get_triplet()) + ':' +
                                  os.path.join(self.path, 'usr', 'lib',
                                               _get_triplet()))
        return env

    def _get_links(self, exe):
        links = set()

        ldd = subprocess.Popen(["ldd", exe],
                         env = self._get_env(),
                         universal_newlines = True,
                         stdout = subprocess.PIPE,
                         stderr = subprocess.PIPE)
        result = ldd.stdout.readlines()

        for r in result:
            s = r.split()
            if '=>' in s:
                if len(s) == 3: # virtual library
                    pass
                else:
                    if s[2].startswith(self.path):
                        links.add(s[2])
            else:
                if len(s) == 2:
                    if s[0].startswith(self.path):
                        links.add(s[0])
        return links

    def _get_libs(self):
        libs = []
        for file in self.get_file_list():
            if 'lib' in file and '.so' in file:
                libs.append(file)
        return libs

    def __init__(self, path):
        super().__init__(path)

    def scan(self):
        '''Run ldd on any binary executables in the snap and check that
        only necessary shared libraries are included
        '''
        print('Scanning {} for unused shared libraries...'.format(self.path),
              end=' ')

        execs = self._get_executables()
        if not execs:
            print('No binary executables found')
            return True
        else:
            used_links = set()
            for exe in execs:
                used_links |= self._get_links(exe)

            unused_libs = set()
            for lib in self._get_libs():
                if self.path + lib not in used_links:
                    unused_libs.add(lib)
            if unused_libs:
                print('FAIL')
                print('Unused libraries found:')
                for lib in unused_libs:
                    print(lib)
                return False
            else:
                print('OK')
                return True
